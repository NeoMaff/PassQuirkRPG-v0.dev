const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');

// Sistema de Exploraci√≥n con Eventos Din√°micos
class ExplorationSystem {
    constructor() {
        this.explorationEvents = [
            {
                type: 'nothing',
                emoji: '‚ùå',
                title: 'Sin Resultados',
                description: 'No has encontrado nada interesante en esta √°rea.',
                probability: 0.35
            },
            {
                type: 'item',
                emoji: 'üéí',
                title: '√çtem Encontrado',
                description: 'Has encontrado un objeto √∫til en tu exploraci√≥n.',
                probability: 0.30
            },
            {
                type: 'enemy',
                emoji: 'üí•',
                title: 'Enemigo Encontrado',
                description: 'Te has topado con un enemigo durante tu exploraci√≥n.',
                probability: 0.20
            },
            {
                type: 'quirk',
                emoji: '‚ú®',
                title: 'Quirk Raro',
                description: 'Has descubierto algo extraordinario y √∫nico.',
                probability: 0.10
            },
            {
                type: 'treasure',
                emoji: 'üíé',
                title: 'Tesoro Oculto',
                description: 'Has encontrado un tesoro valioso bien escondido.',
                probability: 0.05
            }
        ];

        this.items = [
            'Poci√≥n de Curaci√≥n', 'Cristal de Energ√≠a', 'Fragmento Misterioso',
            'Amuleto Antiguo', 'Piedra R√∫nica', 'Elixir M√°gico',
            'Artefacto Perdido', 'Gema Brillante', 'Reliquia Antigua'
        ];

        this.enemies = [
            'Sombra Errante', 'Bestia Salvaje', 'Guardi√°n Corrupto',
            'Esp√≠ritu Maligno', 'Golem de Piedra', 'Lobo Sombr√≠o',
            'Esqueleto Guerrero', 'Ara√±a Gigante', 'Orco Salvaje'
        ];

        this.quirks = [
            'Portal Dimensional', 'Fuente de Poder', 'Altar Misterioso',
            '√Årbol Sagrado', 'Cristal Resonante', 'Ruinas Antiguas',
            'Grieta Temporal', 'Nexo de Energ√≠a', 'Santuario Oculto'
        ];

        this.treasures = [
            'Cofre del Tesoro Perdido', 'Corona de los Antiguos', 'Espada Legendaria',
            'Libro de Hechizos Antiguos', 'Anillo del Poder', 'Collar de Diamantes',
            'B√°culo M√°gico', 'Armadura Celestial', 'C√°liz Dorado'
        ];
    }

    // Generar evento aleatorio basado en probabilidades
    generateRandomEvent(weatherEffects = null) {
        let events = [...this.explorationEvents];
        
        // Aplicar efectos del clima si se proporcionan
        if (weatherEffects) {
            events = events.map(event => {
                if (event.type === 'item' || event.type === 'treasure') {
                    return {
                        ...event,
                        probability: event.probability * weatherEffects.lootBonus
                    };
                }
                if (event.type === 'enemy') {
                    return {
                        ...event,
                        probability: event.probability * weatherEffects.enemySpawn
                    };
                }
                return event;
            });
        }

        const random = Math.random();
        let accumulated = 0;
        
        for (const event of events) {
            accumulated += event.probability;
            if (random <= accumulated) {
                return this.generateEventDetails(event);
            }
        }
        
        return this.generateEventDetails(events[0]); // Fallback
    }

    // Generar detalles espec√≠ficos del evento
    generateEventDetails(eventType) {
        const event = { ...eventType };
        
        switch (event.type) {
            case 'item':
                event.foundItem = this.items[Math.floor(Math.random() * this.items.length)];
                event.description = `Has encontrado: **${event.foundItem}**`;
                break;
                
            case 'enemy':
                event.foundEnemy = this.enemies[Math.floor(Math.random() * this.enemies.length)];
                event.description = `Te enfrentas a: **${event.foundEnemy}**`;
                break;
                
            case 'quirk':
                event.foundQuirk = this.quirks[Math.floor(Math.random() * this.quirks.length)];
                event.description = `Has descubierto: **${event.foundQuirk}**`;
                break;
                
            case 'treasure':
                event.foundTreasure = this.treasures[Math.floor(Math.random() * this.treasures.length)];
                event.description = `¬°Has encontrado: **${event.foundTreasure}**!`;
                break;
        }
        
        return event;
    }

    // Crear embed inicial de exploraci√≥n
    createInitialExplorationEmbed() {
        const embed = new EmbedBuilder()
            .setTitle('üó∫Ô∏è Sistema de Exploraci√≥n')
            .setDescription('¬°Explora el mundo y descubre lo que te aguarda!')
            .setColor('#2ECC71')
            .addFields(
                {
                    name: 'üîç Exploraci√≥n',
                    value: 'Haz clic en **Explorar** para comenzar tu aventura',
                    inline: false
                },
                {
                    name: 'üìä Posibilidades',
                    value: '‚Ä¢ 35% - Sin resultados\n‚Ä¢ 30% - Encontrar √≠tem\n‚Ä¢ 20% - Encontrar enemigo\n‚Ä¢ 10% - Quirk raro\n‚Ä¢ 5% - Tesoro oculto',
                    inline: false
                }
            )
            .setFooter({ text: '‚ö° Los resultados pueden verse afectados por el clima' })
            .setTimestamp();

        return embed;
    }

    // Crear embed de b√∫squeda (mientras explora)
    createSearchingEmbed() {
        const embed = new EmbedBuilder()
            .setTitle('üîé Explorando...')
            .setDescription('Buscando en el √°rea... ¬°Espera un momento!')
            .setColor('#F39C12')
            .addFields({
                name: '‚è±Ô∏è Estado',
                value: 'üîÑ Explorando la zona...',
                inline: false
            })
            .setTimestamp();

        return embed;
    }

    // Crear embed de resultado de exploraci√≥n
    createResultEmbed(event, weatherInfo = null) {
        let color = '#95A5A6'; // Gris por defecto
        
        switch (event.type) {
            case 'nothing':
                color = '#95A5A6';
                break;
            case 'item':
                color = '#3498DB';
                break;
            case 'enemy':
                color = '#E74C3C';
                break;
            case 'quirk':
                color = '#9B59B6';
                break;
            case 'treasure':
                color = '#F1C40F';
                break;
        }

        const embed = new EmbedBuilder()
            .setTitle(`${event.emoji} ${event.title}`)
            .setDescription(event.description)
            .setColor(color)
            .setTimestamp();

        // A√±adir informaci√≥n adicional seg√∫n el tipo de evento
        if (event.type !== 'nothing') {
            embed.addFields({
                name: 'üéØ Resultado',
                value: this.getEventActionText(event),
                inline: false
            });
        }

        // A√±adir informaci√≥n del clima si est√° disponible
        if (weatherInfo) {
            embed.addFields({
                name: 'üå§Ô∏è Efecto del Clima',
                value: weatherInfo.description,
                inline: false
            });
        }

        return embed;
    }

    // Obtener texto de acci√≥n para cada tipo de evento
    getEventActionText(event) {
        switch (event.type) {
            case 'item':
                return 'üéí El √≠tem ha sido a√±adido a tu inventario.';
            case 'enemy':
                return '‚öîÔ∏è ¬°Prep√°rate para el combate!';
            case 'quirk':
                return '‚ú® Este descubrimiento podr√≠a ser muy √∫til.';
            case 'treasure':
                return 'üí∞ ¬°Has obtenido un tesoro muy valioso!';
            default:
                return '‚û°Ô∏è Contin√∫a explorando para encontrar algo interesante.';
        }
    }

    // Crear botones de exploraci√≥n
    createExplorationButtons(isSearching = false, hasHistory = false) {
        const row = new ActionRowBuilder();

        // Bot√≥n de explorar
        const exploreButton = new ButtonBuilder()
            .setCustomId('explore_action')
            .setLabel(isSearching ? 'Explorando...' : 'Explorar')
            .setEmoji('üîç')
            .setStyle(ButtonStyle.Primary)
            .setDisabled(isSearching);

        row.addComponents(exploreButton);

        // Bot√≥n de atr√°s (solo si hay historial)
        if (hasHistory) {
            const backButton = new ButtonBuilder()
                .setCustomId('explore_back')
                .setLabel('Atr√°s')
                .setEmoji('‚¨ÖÔ∏è')
                .setStyle(ButtonStyle.Secondary);
            
            row.addComponents(backButton);
        }

        // Bot√≥n de stats/inventario
        const statsButton = new ButtonBuilder()
            .setCustomId('explore_stats')
            .setLabel('Stats')
            .setEmoji('üìä')
            .setStyle(ButtonStyle.Secondary);

        row.addComponents(statsButton);

        return row;
    }
}

// Manejador del sistema de exploraci√≥n
class ExplorationHandler {
    constructor(explorationSystem, timeWeatherSystem = null) {
        this.explorationSystem = explorationSystem;
        this.timeWeatherSystem = timeWeatherSystem;
        this.explorationHistory = new Map(); // userId -> array de eventos
        this.explorationCooldowns = new Map(); // userId -> timestamp
    }

    // Iniciar exploraci√≥n
    async handleExplorationStart(interaction, userData) {
        const embed = this.explorationSystem.createInitialExplorationEmbed();
        const buttons = this.explorationSystem.createExplorationButtons();

        await interaction.reply({
            embeds: [embed],
            components: [buttons],
            ephemeral: false
        });
    }

    // Manejar acci√≥n de explorar
    async handleExploreAction(interaction, userData) {
        const userId = interaction.user.id;
        
        // Verificar cooldown (opcional)
        if (this.explorationCooldowns.has(userId)) {
            const lastExploration = this.explorationCooldowns.get(userId);
            const cooldownTime = 3000; // 3 segundos
            
            if (Date.now() - lastExploration < cooldownTime) {
                await interaction.reply({
                    content: '‚è±Ô∏è Espera un momento antes de explorar de nuevo.',
                    ephemeral: true
                });
                return;
            }
        }

        // Mostrar estado de b√∫squeda
        const searchingEmbed = this.explorationSystem.createSearchingEmbed();
        const searchingButtons = this.explorationSystem.createExplorationButtons(true, this.hasExplorationHistory(userId));

        await interaction.update({
            embeds: [searchingEmbed],
            components: [searchingButtons]
        });

        // Simular tiempo de exploraci√≥n
        await this.delay(2000 + Math.random() * 2000); // 2-4 segundos

        // Generar evento
        let weatherEffects = null;
        if (this.timeWeatherSystem) {
            weatherEffects = this.timeWeatherSystem.getWeatherEffects();
        }

        const event = this.explorationSystem.generateRandomEvent(weatherEffects);
        
        // Guardar en historial
        this.addToExplorationHistory(userId, event);
        
        // Actualizar cooldown
        this.explorationCooldowns.set(userId, Date.now());

        // Crear embed de resultado
        const resultEmbed = this.explorationSystem.createResultEmbed(event, weatherEffects);
        const resultButtons = this.explorationSystem.createExplorationButtons(false, true);

        try {
            await interaction.editReply({
                embeds: [resultEmbed],
                components: [resultButtons]
            });
            
            // Aqu√≠ puedes a√±adir l√≥gica para actualizar inventario, stats, etc.
            await this.processEventReward(interaction, event, userData);
            
        } catch (error) {
            console.error('Error updating exploration result:', error);
        }
    }

    // Manejar bot√≥n de atr√°s
    async handleExploreBack(interaction, userData) {
        const userId = interaction.user.id;
        const history = this.explorationHistory.get(userId) || [];
        
        if (history.length < 2) {
            await interaction.reply({
                content: '‚ùå No hay eventos anteriores para mostrar.',
                ephemeral: true
            });
            return;
        }

        // Mostrar el evento anterior (pen√∫ltimo)
        const previousEvent = history[history.length - 2];
        let weatherEffects = null;
        if (this.timeWeatherSystem) {
            weatherEffects = this.timeWeatherSystem.getWeatherEffects();
        }

        const embed = this.explorationSystem.createResultEmbed(previousEvent, weatherEffects);
        const buttons = this.explorationSystem.createExplorationButtons(false, true);

        await interaction.update({
            embeds: [embed],
            components: [buttons]
        });
    }

    // Funciones auxiliares
    hasExplorationHistory(userId) {
        const history = this.explorationHistory.get(userId) || [];
        return history.length > 0;
    }

    addToExplorationHistory(userId, event) {
        if (!this.explorationHistory.has(userId)) {
            this.explorationHistory.set(userId, []);
        }
        
        const history = this.explorationHistory.get(userId);
        history.push(event);
        
        // Mantener solo los √∫ltimos 10 eventos
        if (history.length > 10) {
            history.shift();
        }
    }

    async delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Procesar recompensas del evento (implementar seg√∫n tu sistema)
    async processEventReward(interaction, event, userData) {
        // Aqu√≠ a√±ades la l√≥gica para:
        // - A√±adir √≠tems al inventario
        // - Iniciar combate si es un enemigo
        // - Dar experiencia o monedas
        // - Activar quirks especiales
        // etc.
        
        console.log(`Procesando evento ${event.type} para usuario ${interaction.user.id}`);
        
        // Ejemplo b√°sico de notificaci√≥n
        if (event.type === 'treasure') {
            setTimeout(async () => {
                try {
                    await interaction.followUp({
                        content: `üéâ ¬°Felicidades! Has obtenido un tesoro excepcional.`,
                        ephemeral: true
                    });
                } catch (error) {
                    console.error('Error sending follow-up:', error);
                }
            }, 1000);
        }
    }
}

module.exports = { ExplorationSystem, ExplorationHandler };